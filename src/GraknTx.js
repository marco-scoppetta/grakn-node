const GrpcCommunicator = require("./util/GrpcCommunicator");
const GrpcIterator = require("./util/GrpcIterator");
const ConceptFactory = require("./ConceptFactory");
const messages = require("./autogenerated/grakn_pb");

function GraknTx(client, keyspace, credentials) {
    this.client = client;
    this.communicator = null;
    this._isOpen = false;
    this.credentials = credentials;
    this.keyspace = keyspace;
    this.conceptFactory = null;
}

GraknTx.prototype._openTx = async function () {
    const openRequest = new messages.Open();
    const txRequest = new messages.TxRequest();
    const messageKeyspace = new messages.Keyspace();
    messageKeyspace.setValue(this.keyspace);

    openRequest.setKeyspace(messageKeyspace);
    openRequest.setTxtype(messages.TxType.WRITE);
    openRequest.setUsername(this.credentials.username);
    openRequest.setPassword(this.credentials.password);
    txRequest.setOpen(openRequest);

    await this.communicator.send(txRequest)
        // Explicitly catch and re-throw exception otherwise it will be swallowed by promises
        .catch((e) => {
            throw e;
        });
};

GraknTx.prototype._parseResponse = async function parseResponse(resp) {
    if (resp.hasDone()) return [];
    if (resp.hasIteratorid()) {
        const iterator = new GrpcIterator.GrpcQueryIterator(
            resp.getIteratorid(),
            this.communicator
        );
        const executeQueryResult = [];
        let nextResult = await iterator.nextResult();
        while (nextResult) {
            executeQueryResult.push(this._parseResult(nextResult));
            nextResult = await iterator.nextResult();
        }
        return executeQueryResult;
    }
};

GraknTx.prototype._parseResult = function parseResult(queryResult) {
    if (queryResult.hasOtherresult()) {
        // compute or aggregate query
        this.result = JSON.parse(queryResult.getOtherresult());
    } else {
        const answerMap = new Map();
        queryResult
            .getAnswer()
            .getAnswerMap()
            .forEach((grpcConcenpt, key) => {
                answerMap.set(
                    key,
                    this.conceptFactory.createConcept(grpcConcenpt, this.communicator, this.conceptFactory)
                );
            });
        return answerMap;
    }
};

GraknTx.prototype.execute = async function executeQuery(query) {
    this.result = [];
    const txRequest = new messages.TxRequest();
    const executeQuery = new messages.ExecQuery();
    const queryRequest = new messages.Query();
    queryRequest.setValue(query);
    executeQuery.setQuery(queryRequest);
    txRequest.setExecquery(executeQuery);
    return await this.communicator
        .send(txRequest)
        .then(resp => this._parseResponse(resp))
        .catch((e) => {
            throw e;
        });
};

GraknTx.prototype.open = async function () {
    if (this._isOpen) throw "Transaction is already open.";
    if (!this.communicator) {
        this.communicator = new GrpcCommunicator(this.client.tx());
        this.conceptFactory = new ConceptFactory(this.communicator);
    }
    await this._openTx()
        .then(() => { this._isOpen = true; })
        .catch((e) => {
            throw e;
        });
};

GraknTx.prototype.isOpen = function () { return this._isOpen; }



module.exports = GraknTx;